<!doctype html>
<html
    xmlns="http://www.w3.org/1999/xhtml"
    lang="$lang$"
    xml:lang="$lang$"
    $if(dir)$
    dir="$dir$"
    $endif$
>
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=yes"
        />
        $for(author-meta)$
        <meta name="author" content="$author-meta$" />
        $endfor$ $if(date-meta)$
        <meta name="dcterms.date" content="$date-meta$" />
        $endif$ $if(keywords)$
        <meta
            name="keywords"
            content="$for(keywords)$$keywords$$sep$, $endfor$"
        />
        $endif$ $if(description-meta)$
        <meta name="description" content="$description-meta$" />
        $endif$
        <title>$if(title-prefix)$$title-prefix$ – $endif$$pagetitle$</title>
        <style>
            $styles.html()$
        </style>
        $for(css)$
        <link rel="stylesheet" href="$css$" />
        $endfor$ $for(header-includes)$ $header-includes$ $endfor$
        <script
            data-external="1"
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        ></script>
        <script>
        // Tabset functionality for pandoc-rendered markdown
        // Emulates R Markdown's {.tabset} behavior
        document.addEventListener('DOMContentLoaded', function() {
          // Find all headers with 'tabset' class (pandoc applies class to header, not section)
          document.querySelectorAll('h1.tabset, h2.tabset, h3.tabset, h4.tabset, h5.tabset, h6.tabset').forEach(function(tabsetHeader) {
            const tabLevel = parseInt(tabsetHeader.tagName[1]);
            const childHeaderTag = 'H' + (tabLevel + 1);

            // Find all child sections (tabs) - siblings until next same-level header
            const tabs = [];
            const introContent = []; // Content before first tab
            let currentTab = null;

            let sibling = tabsetHeader.nextElementSibling;
            while (sibling) {
              if (sibling.tagName === childHeaderTag) {
                // New tab starts
                if (currentTab) tabs.push(currentTab);
                currentTab = {
                  title: sibling.textContent,
                  id: sibling.id || sibling.textContent.toLowerCase().replace(/\s+/g, '-'),
                  header: sibling,
                  content: []
                };
              } else if (sibling.tagName && sibling.tagName[0] === 'H' && parseInt(sibling.tagName[1]) <= tabLevel) {
                // Hit a same-level or higher header, stop
                break;
              } else if (currentTab) {
                // Add content to current tab
                currentTab.content.push(sibling);
              } else {
                // Content before first tab (intro text)
                introContent.push(sibling);
              }
              sibling = sibling.nextElementSibling;
            }
            if (currentTab) tabs.push(currentTab);

            if (tabs.length === 0) return;

            // Create tab UI
            const tabContainer = document.createElement('div');
            tabContainer.className = 'tab-container';

            // Create tab buttons
            const tabButtons = document.createElement('div');
            tabButtons.className = 'tab-buttons';

            tabs.forEach(function(tab, index) {
              const button = document.createElement('button');
              button.className = 'tab-button' + (index === 0 ? ' active' : '');
              button.textContent = tab.title;
              button.setAttribute('data-tab', tab.id);
              button.addEventListener('click', function() {
                // Deactivate all tabs in this container
                tabContainer.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                tabContainer.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                // Activate clicked tab
                button.classList.add('active');
                tabContainer.querySelector('.tab-panel[data-tab="' + tab.id + '"]').classList.add('active');
              });
              tabButtons.appendChild(button);
            });

            tabContainer.appendChild(tabButtons);

            // Create tab panels and move content
            tabs.forEach(function(tab, index) {
              const panel = document.createElement('div');
              panel.className = 'tab-panel' + (index === 0 ? ' active' : '');
              panel.setAttribute('data-tab', tab.id);
              tab.content.forEach(function(el) {
                panel.appendChild(el);
              });
              tabContainer.appendChild(panel);
              // Remove the original tab header
              tab.header.remove();
            });

            // Insert intro content right after tabset header, then tab container
            let insertPoint = tabsetHeader;
            introContent.forEach(function(el) {
              insertPoint.after(el);
              insertPoint = el;
            });
            insertPoint.after(tabContainer);
          });

          // Image Maximizer functionality
          // Wraps images and SVGs in containers with expand functionality
          const wrapElement = function(element) {
            // Skip if already wrapped
            if (element.parentElement && element.parentElement.classList.contains('img-wrapper')) return;

            // Get element dimensions
            const getWidth = function() {
              if (element.tagName === 'IMG') {
                return element.naturalWidth || element.width || element.clientWidth;
              } else if (element.tagName === 'SVG') {
                // For inline SVGs, try multiple methods to get width
                // 1. Check viewBox attribute for intended dimensions
                const viewBox = element.getAttribute('viewBox');
                if (viewBox) {
                  const parts = viewBox.split(/\s+|,/);
                  if (parts.length >= 4) {
                    const vbWidth = parseFloat(parts[2]);
                    if (vbWidth > 0) return vbWidth;
                  }
                }
                // 2. Check explicit width attribute
                const widthAttr = element.getAttribute('width');
                if (widthAttr && !widthAttr.includes('%')) {
                  const w = parseFloat(widthAttr);
                  if (w > 0) return w;
                }
                // 3. Try getBBox (may throw if SVG not rendered)
                try {
                  const bbox = element.getBBox ? element.getBBox() : null;
                  if (bbox && bbox.width > 0) return bbox.width;
                } catch (e) {
                  // getBBox can throw if element is not in DOM or not rendered
                }
                // 4. Fall back to client dimensions
                return element.clientWidth || element.getBoundingClientRect().width;
              }
              return 0;
            };

            // Only apply to images/SVGs wider than 200px (skip small icons)
            const width = getWidth();
            if (width < 200) return;

            // Handle parent element - <div> inside <p> is invalid HTML and breaks rendering
            const parent = element.parentNode;
            if (parent && parent.tagName === 'P') {
              // Replace <p> with <figure> to allow block-level content
              const figure = document.createElement('figure');
              figure.className = 'img-figure';
              // Move all children from <p> to <figure>
              while (parent.firstChild) {
                figure.appendChild(parent.firstChild);
              }
              parent.parentNode.replaceChild(figure, parent);
            }

            // Create wrapper
            const wrapper = document.createElement('div');
            wrapper.className = 'img-wrapper';

            // Create expand icon
            const expandIcon = document.createElement('div');
            expandIcon.className = 'img-expand-icon';
            expandIcon.innerHTML = '⤢'; // Expand arrow symbol
            expandIcon.setAttribute('title', 'Click to expand');

            // Wrap element and add icon
            element.parentNode.insertBefore(wrapper, element);
            wrapper.appendChild(element);
            wrapper.appendChild(expandIcon);

            // Add click handler to maximize
            const maximize = function() {
              // Prevent body scroll
              document.body.style.overflow = 'hidden';

              // Create overlay
              const overlay = document.createElement('div');
              overlay.className = 'img-maximized-overlay';

              // Create content container
              const content = document.createElement('div');
              content.className = 'img-maximized-content';

              // Clone element
              const maximizedElement = element.cloneNode(true);
              maximizedElement.className = 'img-maximized';

              // Create close button
              const closeBtn = document.createElement('button');
              closeBtn.className = 'img-close-btn';
              closeBtn.innerHTML = '×';
              closeBtn.setAttribute('title', 'Close (ESC)');

              // Assemble
              content.appendChild(maximizedElement);
              content.appendChild(closeBtn);
              overlay.appendChild(content);
              document.body.appendChild(overlay);

              // Trigger animation
              setTimeout(function() {
                overlay.classList.add('active');
              }, 10);

              // Close handlers
              const close = function() {
                overlay.classList.remove('active');
                setTimeout(function() {
                  overlay.remove();
                  document.body.style.overflow = '';
                }, 200); // Match CSS transition time
              };

              closeBtn.addEventListener('click', close);
              overlay.addEventListener('click', function(e) {
                if (e.target === overlay) close();
              });
              document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                  close();
                  document.removeEventListener('keydown', escHandler);
                }
              });
            };

            element.addEventListener('click', maximize);
            expandIcon.addEventListener('click', maximize);
          };

          // Process inline SVGs immediately
          document.querySelectorAll('svg').forEach(wrapElement);

          // Process images - wait for load to get accurate dimensions
          document.querySelectorAll('img').forEach(function(img) {
            if (img.complete) {
              wrapElement(img);
            } else {
              img.addEventListener('load', function() {
                wrapElement(img);
              });
            }
          });
        });
        </script>
    </head>
    <body>
        $for(include-before)$ $include-before$ $endfor$ $if(title)$
        <header id="title-block-header">
            <div class="left">
                <h1 class="title">$title$</h1>
                $if(subtitle)$
                <p class="subtitle">$subtitle$</p>
                $endif$
            </div>
            <div class="right">
                $for(author)$
                <p class="author">$author$</p>
                $endfor$ $if(date)$
                <p class="date">$date$</p>
                $endif$
            </div>
        </header>
        $endif$ $if(toc)$
        <nav id="$idprefix$TOC" role="doc-toc">
            $if(toc-title)$
            <h2 id="$idprefix$toc-title">$toc-title$</h2>
            $endif$ $table-of-contents$
        </nav>
        $endif$ $body$ $for(include-after)$ $include-after$ $endfor$
    </body>
</html>
